#!/bin/bash

less_command='| less $less_no_init -aiF -Ps"Manual page\: $man_page (?ltline %lt?L/%L.:byte %bB?s/%s..? (END):?pB %pB\%..)"'
grepopts='-i'  # grep case-insensitive by default

# Get section
if [[ $1 =~ [0-9]+ ]]
then
    section=$1
    shift
fi

# Find the longest set of args that gets a man page
man_page=("$@")
while ! command man -w $(echo "${man_page[@]}" | tr " " "-") &>/dev/null
do
    patterns+=( ${man_page[-1]} )
    unset man_page[-1]
done

# For some reason, using an array substitution in the prompt string in
# less_command isn't working, so work around that by turning it into a
# plain string
man_page="${man_page[@]}"

# Build grep command
if [[ ${patterns[@]} ]]
then
	# If first "pattern" is 'opt' then add some regex to next pattern (should allow more than one pattern to be converted this way)
	if [ "${patterns[-1]}" = 'opt' ]
	then
		if [ "${#patterns[@]}" -gt 1 ]
		then
			unset patterns[-1]
			patterns[-1]="'^ *${patterns[-1]}[ ,]'"
			# grep case-sensitive if there's an opt pattern
			grepopts=''
		else
			# opt by itself just looks for any leading hyphen
			patterns[-1]="'^ *-[A-Z]*[ ,]'"
		fi
	fi

    grep_command="| grep $grepopts -C4 --color=always ${patterns[@]/#/-e }"
fi

# Patterns given on command line, so give grep version
if [[ ${patterns[@]} ]]; then
	# Show man page with search patterns highlighted, piped through less
	command="command man $section $man_page $grep_command"
else
	# If no patterns, don't pipe through less (to keep man page TERMCAP coloring)
	command="command man $section $man_page"
	less_command=''
fi

# Check screen and output sizes (only do this if actually piping into less. Reason: wc chokes on mpv's man page)
if [ ! -z "$less_command" ]; then
	tty_lines=$(tput lines)
	output_lines=$(eval "$command" | wc -l)

	# If output < screen size, use less with -X
	[[ $output_lines -lt $tty_lines ]] && less_no_init="-X"
fi

# Display the page
eval "$command $less_command"
